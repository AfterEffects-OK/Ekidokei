<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ネオン風 駅時計</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSSカスタムプロパティを定義 */
        :root {
            --neon-color: #c7ff44; /* ネオンカラーを #c7ff44 に更新 */
            --dark-background: #111111; /* 一番外側の背景色を濃い黒に変更 */
        }
        
        /* 全体レイアウト */
        body { 
            font-family: 'Inter', sans-serif; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 中央寄せ */
            padding: 1rem;
            background-color: var(--dark-background); 
            position: relative; /* グリッドエフェクトの基準点 */
            color: white;
            transition: background-color 0.5s;
        }

        /* --- iOS擬似フルスクリーン用スタイル (アドレスバー非表示は不可) --- */
        .ios-fullscreen-active {
            /* ページ全体の余白/パディングを削除 */
            margin: 0 !important;
            padding: 0 !important;
            width: 100vw;
            height: 100vh;
            overflow: hidden; /* スクロールを禁止 */
        }
        /* iOS擬似フルスクリーン時の時計コンテナのサイズ調整 */
        .ios-fullscreen-active #clockContainer {
            /* 縦横比を保ちつつ、ビューポートの短い辺(vmin)に合わせて最大化 (98vminに変更し、iOSでの表示領域のズレを吸収) */
            width: 98vmin !important; 
            /* 縦長画面で縦いっぱいに広がるように、最大値をビューポートの高さに合わせる */
            max-width: 100vh !important;
            max-height: 100vh !important;
        }
        /* -------------------------------------- */

        /* --- グリッド/スキャンラインエフェクト --- */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* subtle grid pattern */
            background: 
                repeating-linear-gradient(to right, rgba(0,0,0,.15), rgba(0,0,0,.15) 1px, transparent 1px, transparent 40px),
                repeating-linear-gradient(to bottom, rgba(0,0,0,.15), rgba(0,0,0,.15) 1px, transparent 1px, transparent 40px);
            z-index: -1;
            opacity: 0.5;
            transition: opacity 0.5s;
        }
        .no-grid::before {
            opacity: 0;
        }
        /* -------------------------------------- */
        
        /* ボタンのスタイル (ネオングローと境界線を削除) */
        .neon-button {
            background-color: var(--dark-background); 
            /* ネオン境界線とシャドウを削除しました */
            color: white;
            transition: transform 0.3s, background-color 0.3s, box-shadow 0.3s; /* 変化を滑らかにする */
            z-index: 30;
        }
        .neon-button:hover {
            transform: scale(1.05); /* ホバー時の拡大効果は維持 */
            box-shadow: none; /* グロー効果は適用しない */
        }
        
        /* 追加: フルスクリーン中のボタンの状態 */
        .is-fullscreen {
            /* 押されている感じを出すために少し暗い色に */
            background-color: #222222; 
            /* 控えめな白い境界線 (内側の影) を適用してアクティブ状態を示す */
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5) inset;
            transform: scale(1.02); /* わずかにスケールを維持 */
        }
        
        .is-fullscreen:hover {
            transform: scale(1.08); /* ホバー時の拡大を少し強くする */
        }


        /* 時計コンテナのスタイル - レスポンシブの中核 */
        #clockContainer {
            /* 変更: 画面の短い方に合わせてサイズを確保 (96vmin に変更し、ブラウザUIの安全マージンを確保) */
            width: 96vmin;      
            max-width: 100%;    
            max-height: 100%; /* 縦画面/横画面の制限を親要素内に収まるように変更 */
            aspect-ratio: 1 / 1; /* 正方形を維持 */
            background-color: transparent; 
            border-radius: 0; 
            box-shadow: none; 
            padding: 0;
            transition: transform 300ms;
            position: relative; /* 歯車アイコンの配置基準 */
        }

        /* Canvasのスタイル */
        #clockCanvas {
            border-radius: 0; 
            display: block; 
            width: 100%;
            height: 100%;
        }

        /* モーダル表示のためのユーティリティクラス */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }
        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 300ms, transform 300ms;
        }
    </style>
    <script>
        // グローバル変数
        let canvas, ctx, radius;
        let neonColorState; // 現在のネオン色を保持する状態変数
        
        // 設定
        const DIAL_COLOR = '#225822'; // 文字盤の内部背景色（濃い緑）に戻しました

        // 文字盤画像の設定
        let faceImageUrl = 'https://raw.githubusercontent.com/AfterEffects-OK/Ekidokei/main/base.png'; 
        let faceImageObj = null;
        let isImageLoaded = false;

        /**
         * 角度をラジアンに変換するヘルパー関数
         */
        function toRadians(degrees) {
            return (Math.PI / 180) * degrees;
        }
        
        /**
         * CSSカスタムプロパティから現在のネオン色を取得
         */
        function getNeonColor() {
            return getComputedStyle(document.documentElement).getPropertyValue('--neon-color').trim();
        }

        /**
         * ユーザーエージェントからiOSデバイスを判定
         */
        function isIOS() {
            return [
                'iPad Simulator',
                'iPhone Simulator',
                'iPod Simulator',
                'iPad',
                'iPhone',
                'iPod'
            ].includes(navigator.platform)
            // iPadOS 13+ detection
            || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
        }

        /**
         * メッセージボックスを表示する
         */
        function showMessage(message, colorClass = 'bg-blue-500') {
            const box = document.getElementById('messageBox');
            box.className = `fixed bottom-4 right-4 text-white p-3 rounded-lg shadow-xl transition-opacity duration-300 z-50 ${colorClass}`;
            box.textContent = message;
            box.classList.remove('hidden', 'opacity-0');
            box.classList.add('opacity-100');

            setTimeout(() => {
                box.classList.remove('opacity-100');
                box.classList.add('opacity-0');
                setTimeout(() => box.classList.add('hidden'), 300);
            }, 5000); // メッセージの表示時間を長くしました (5秒)
        }

        /**
         * 画像を非同期で読み込み、Canvasに適用する
         */
        function loadImage(url) {
            isImageLoaded = false;
            faceImageObj = null;

            if (!url || url.trim() === '') {
                drawClock(); // URLが空なら画像なしで描画を継続
                return;
            }

            const img = new Image();
            img.crossOrigin = 'anonymous'; // CORS対応
            
            // タイムアウトを設定
            const timeout = setTimeout(() => {
                img.onload = null; 
                img.onerror = null; 
                showMessage(`画像ロードがタイムアウトしました。`, 'bg-red-500');
                drawClock();
            }, 5000); 

            img.onload = () => {
                clearTimeout(timeout); 
                faceImageObj = img;
                isImageLoaded = true;
                showMessage('新しい文字盤画像を適用しました。', 'bg-green-500');
                // drawClock() は requestAnimationFrame で既に動いているため、再描画を待つ
            };
            img.onerror = () => {
                clearTimeout(timeout); 
                // UIにも入力されたURLが問題がある可能性があることを警告
                showMessage(`カスタム画像の読み込みに失敗しました。URLを確認してください。`, 'bg-red-500');
                // drawClock() は requestAnimationFrame で既に動いているため、再描画を待つ
            };
            img.src = url;
        }

        /**
         * UIからURLを取得し、画像ロードをトリガーする
         */
        function applyImage() {
            // UIから取得する際も、faceImageUrlを更新してからloadImageを呼ぶ
            faceImageUrl = document.getElementById('faceImageUrl').value;
            loadImage(faceImageUrl);
        }
        
        /**
         * ネオンカラーの変更を適用する
         */
        function changeNeonColor(newColor) {
            // 1. CSS変数も更新 (UIボタン、ボディのネオン効果用)
            document.documentElement.style.setProperty('--neon-color', newColor);
            // 2. JSの状態も更新 (Canvas描画用)
            neonColorState = newColor;
            // requestAnimationFrame で自動更新される
            
            // UI上の色プレビューを更新
            document.getElementById('neonColorPreview').style.backgroundColor = newColor;
            
            showMessage(`ネオンカラーを ${newColor} に変更しました。`, 'bg-indigo-500');
        }

        /**
         * グリッドエフェクトの表示/非表示を切り替える
         */
        function toggleGridEffect(isOn) {
            document.body.classList.toggle('no-grid', !isOn);
            showMessage(`背景グリッドエフェクトを${isOn ? '有効' : '無効'}にしました。`, 'bg-indigo-500');
        }

        /**
         * フルスクリーンモードの切り替え
         */
        function toggleFullscreen() {
            // iOS判定: iOSの場合は擬似フルスクリーンに切り替える
            if (isIOS()) {
                const isCurrentlyPseudoFullscreen = document.body.classList.contains('ios-fullscreen-active');
                
                document.body.classList.toggle('ios-fullscreen-active', !isCurrentlyPseudoFullscreen);
                handleFullscreenChange(); // ボタンの状態を更新
                
                // PWA実行を促すメッセージに更新
                const message = !isCurrentlyPseudoFullscreen 
                    ? '【iOSの制限】アドレスバーは非表示になりません。完全に隠すには、ブラウザの共有メニューから「ホーム画面に追加」してPWAとして起動してください。擬似フルスクリーンモードを有効にしました。'
                    : '擬似フルスクリーンモードを無効にしました。';
                showMessage(message, !isCurrentlyPseudoFullscreen ? 'bg-yellow-600' : 'bg-indigo-500');
                return; // iOSの場合はここで処理を終了
            }

            // 標準フルスクリーンAPIを使用
            if (!document.fullscreenElement) {
                // フルスクリーンを開始
                document.documentElement.requestFullscreen().catch(err => {
                    showMessage(`フルスクリーンモードを開始できませんでした: ${err.message}`, 'bg-red-500');
                });
            } else {
                // フルスクリーンを終了
                document.exitFullscreen();
            }
        }

        /**
         * フルスクリーン状態が変更されたときにボタンのアイコンを更新する
         */
        function handleFullscreenChange() {
            const btn = document.getElementById('fullscreenToggleBtn');
            const iconContainer = btn.querySelector('#fullscreenIcon');
            
            // 標準APIまたはiOS擬似フルスクリーンのどちらかがアクティブかチェック
            const isFullscreen = document.fullscreenElement || document.body.classList.contains('ios-fullscreen-active');

            // フルスクリーン状態に応じて 'is-fullscreen' クラスをトグル
            btn.classList.toggle('is-fullscreen', isFullscreen); 
            
            // 既存のアイコンをクリア
            iconContainer.innerHTML = ''; 

            if (isFullscreen) {
                // フルスクリーン中のアイコン (最小化/終了)
                iconContainer.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
                    </svg>
                `;
            } else {
                // 通常モードのアイコン (最大化/開始)
                iconContainer.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 8V4h4"/><path d="M20 8V4h-4"/><path d="M4 16v4h4"/><path d="M16 20h4v-4"/>
                    </svg>
                `;
            }
        }
        
        /**
         * 設定モーダルを開く
         */
        function openSettingsModal() {
            const modal = document.getElementById('settingsModal');
            const content = document.getElementById('settingsModalContent');
            
            modal.classList.remove('hidden');
            
            // アニメーションを適用
            content.classList.remove('modal-enter');
            content.classList.add('modal-enter-active');
            
            // UIのURL表示を現在の値に更新
            document.getElementById('faceImageUrl').value = faceImageUrl;
        }

        /**
         * 設定モーダルを閉じる
         */
        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            const content = document.getElementById('settingsModalContent');

            // アニメーションを逆再生
            content.classList.remove('modal-enter-active');
            content.classList.add('modal-enter');

            setTimeout(() => {
                 modal.classList.add('hidden');
            }, 300); // CSS transition durationに合わせる
        }

        /**
         * 時計の描画処理をフレームレートに合わせて実行
         */
        function drawClock() {
            // 毎回クリアして再描画
            ctx.clearRect(-radius, -radius, radius * 2, radius * 2); 
            
            // 1. 文字盤の描画
            drawFace(ctx, radius);
            
            // --- 2. デジタル時計のCanvas内描画 (針の下に表示するため、ここで描画) ---
            const now = new Date();
            let h = now.getHours();
            const m = now.getMinutes();
            const s = now.getSeconds();
            
            // 0埋めして表示
            const digitalText = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            
            const color = neonColorState;

            ctx.save();
            
            // 配置設定
            ctx.font = 'bold ' + radius * 0.12 + "px Inter, sans-serif"; // サイズ調整
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            
            // 中央より上に配置 (半径の約20%の位置に調整)
            const yPosition = radius * 0.20; 
            const textMetrics = ctx.measureText(digitalText);
            const textWidth = textMetrics.width;
            const textHeight = radius * 0.12 * 1.2; // おおよその高さ
            
            // 1. 黒い背景を描画
            ctx.fillStyle = '#000000'; // 黒
            ctx.shadowBlur = 0; // 背景にはグローなし
            ctx.fillRect(
                -textWidth / 2 - radius * 0.02, // X座標: 中央から左にテキスト幅の半分 + パディング
                yPosition - textHeight / 2 - radius * 0.02, // Y座標: 中央から上にテキスト高さの半分 + パディング
                textWidth + radius * 0.04, // 幅: テキスト幅 + 両側パディング
                textHeight + radius * 0.04 // 高さ: テキスト高さ + 上下パディング
            );


            // 2. テキスト（ネオンカラー）を描画
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            // グロー効果を大幅に抑えるために値を小さく設定
            ctx.shadowBlur = radius * 0.005; 
            
            ctx.fillText(digitalText, 0, yPosition);

            ctx.restore();
            // -------------------------------------------------------------
            
            // 3. 針の描画 (最後に描画することで最前面になる)
            drawTime(ctx, radius); 

            // スイープ運針 (滑らかな動き) のため、requestAnimationFrameで継続的に描画
            window.requestAnimationFrameId = requestAnimationFrame(drawClock);
        }

        /**
         * 文字盤と目盛り、数字を描画します (ネオン効果込み)
         */
        function drawFace(ctx, radius) {
            const color = neonColorState;

            // 1. 背景色の描画（画像がない場合）
            if (!isImageLoaded) {
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.95, 0, 2 * Math.PI);
                ctx.fillStyle = DIAL_COLOR;
                ctx.fill();
            }

            // 1b. カスタム画像の描画 (正方形クリッピング)
            if (faceImageObj && isImageLoaded) {
                const imgSize = radius * 2; 

                // 正方形のクリッピングパスを設定
                ctx.save();
                ctx.beginPath();
                ctx.rect(-radius, -radius, imgSize, imgSize); 
                ctx.clip(); 
                
                // 画像を中央に、正方形エリアにぴったり収まるように描画
                ctx.drawImage(faceImageObj, -radius, -radius, imgSize, imgSize);
                
                ctx.restore(); 
            }

            // 3. 目盛りと数字を描画 (画像が適用されていない場合のみ実行)
            // 画像がロードされている場合、目盛りと数字の描画はスキップされる
            if (!isImageLoaded) { 
                ctx.fillStyle = color; 
                ctx.strokeStyle = color; 
                
                // ネオン効果を設定
                ctx.shadowBlur = radius * 0.015;
                ctx.shadowColor = color;

                // 目盛りを描画
                for (let i = 1; i <= 60; i++) {
                    ctx.beginPath();
                    const angle = toRadians(i * 6); 
                    const isHourMark = i % 5 === 0;

                    const markLength = isHourMark ? radius * 0.08 : radius * 0.03; 
                    const markWidth = isHourMark ? radius * 0.02 : radius * 0.008; 

                    const x1 = Math.sin(angle) * radius * 0.90; 
                    const y1 = -Math.cos(angle) * radius * 0.90; 
                    const x2 = Math.sin(angle) * (radius * 0.90 - markLength); 
                    const y2 = -Math.cos(angle) * (radius * 0.90 - markLength); 
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineWidth = markWidth;
                    ctx.lineCap = 'round'; 
                    ctx.stroke();
                }

                // 数字を描画
                ctx.font = 'bold ' + radius * 0.15 + "px Arial, sans-serif";
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";

                for(let num = 1; num <= 12; num++){
                    const angle = num * Math.PI / 6;
                    const x = radius * 0.75 * Math.sin(angle); 
                    const y = radius * 0.75 * -Math.cos(angle);
                    ctx.fillText(num.toString(), x, y);
                }
            }
            
            // 針の描画に移るため、グロー効果はリセットしない
        }


        /**
         * 時針、分針、秒針を描画します
         */
        function drawTime(ctx, radius) {
            const now = new Date();
            let hour = now.getHours();
            let minute = now.getMinutes();
            let second = now.getSeconds();
            let millisecond = now.getMilliseconds();
            const color = neonColorState;

            // 角度の計算
            hour = hour % 12;
            let hourAngle = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60));
            // 分針の角度: スイープ運針を維持。長さを2%短縮 (0.7 -> 0.686)
            let minuteAngle = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)) + (millisecond * Math.PI / (30 * 60 * 1000));
            
            // 秒針の角度: 1秒ごとのステップ運針
            let secondAngle = (second * Math.PI / 30); 

            // グロー効果を設定 (0.02 -> 0.01 に弱体化)
            ctx.shadowBlur = radius * 0.01;
            ctx.shadowColor = color;

            // 秒針を描画 (長さ: radius * 0.70, 根本の幅: 0.015)
            drawHand(ctx, secondAngle, radius * 0.70, radius * 0.015, color, 'second'); 
            // 分針を描画 (長さ: radius * 0.686, 根本の幅: 0.04)
            drawHand(ctx, minuteAngle, radius * 0.686, radius * 0.04, color, 'minute'); 
            // 時針を描画 (長さ: radius * 0.40, 根本の幅: 0.08)
            drawHand(ctx, hourAngle, radius * 0.40, radius * 0.08, color, 'hour'); 

            // 中央のピン (少し大きく、より強く光らせる)
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.04, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            // グロー効果を弱体化 (0.05 -> 0.025 に弱体化)
            ctx.shadowBlur = radius * 0.025; 
            ctx.shadowColor = color;
            ctx.fill();

            // 全てのグロー効果をリセット
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        /**
         * 針の描画ヘルパー関数 (太い本体と尖った先端を持つ多角形描画)
         */
        function drawHand(ctx, pos, length, baseWidth, color, type) {
            
            ctx.save();
            ctx.rotate(pos); // 針の角度に回転
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = radius * 0.005; // 輪郭線は細く設定

            // 尾部の長さ (時針は短く、秒針は長め)
            const tailLength = radius * (type === 'second' ? 0.2 : type === 'minute' ? 0.1 : 0.05);
            
            // 時針・分針の先端形状設定
            let tipBaseWidth = 0; // 尖り始める部分の幅
            
            // 長針は針の長さの98%の位置から先端に向かって鋭い三角形になるように設定
            const tipLengthRatio = (type === 'minute') ? 0.98 : 0.96; 
            
            // 時針または分針の場合
            if (type === 'minute' || type === 'hour') {
                // 尖り始める部分の幅を、根元の幅の約50%に設定
                tipBaseWidth = baseWidth * 0.5; 
            }

            // 針の形状の定義 (多角形)
            ctx.beginPath();
            
            // 1. 根本の左下 (尾部の端)
            ctx.moveTo(-baseWidth / 2, tailLength); 
            
            // 2. 根本の右下 (尾部の端)
            ctx.lineTo(baseWidth / 2, tailLength); 
            
            // 3. 根元上部（中心）の右側 (幅 baseWidth * 0.4 の地点)
            ctx.lineTo(baseWidth * 0.4, 0); 
            
            // --- 尖った先端部分の定義 ---
            if (tipBaseWidth > 0) {
                const bodyLength = length * tipLengthRatio;
                
                // 4. 太い本体の終わり（右側）
                // 根元の幅からこの位置まで滑らかに細くなっている
                ctx.lineTo(tipBaseWidth / 2, -bodyLength); 
                
                // 5. 頂点 (鋭利な先端)
                ctx.lineTo(0, -length); 
                
                // 6. 太い本体の終わり（左側）
                ctx.lineTo(-tipBaseWidth / 2, -bodyLength);
                
                // 7. 根元上部（中心）の左側に戻る
                ctx.lineTo(-baseWidth * 0.4, 0); 
            } else {
                // 秒針の場合 (tipBaseWidth = 0) - 全体が尖った矢印
                ctx.lineTo(0, -length); // 頂点
                ctx.lineTo(-baseWidth * 0.4, 0); // 根元上部（中心）の左側に戻る
            }
            // -------------------------------------------------------------

            ctx.closePath();
            
            ctx.fill(); // 塗りつぶし
            ctx.stroke(); // 輪郭線

            ctx.restore(); // 回転を元に戻す
        }


        /**
         * Canvasのサイズを親要素に合わせて設定し、再描画する (レスポンシブ対応)
         */
        function resizeCanvas() {
            const container = canvas.parentNode;
            const size = container.offsetWidth;
            const scale = window.devicePixelRatio || 1;
            
            // 論理サイズを設定
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            // 物理ピクセルサイズを設定
            canvas.width = size * scale;
            canvas.height = size * scale;

            // 描画コンテキストをスケーリング
            ctx.scale(scale, scale);
            
            // 描画の原点を中心に移動し直す
            radius = size / 2;
            ctx.setTransform(scale, 0, 0, scale, 0, 0); // スケールのみ適用し、トランスフォームをリセット
            ctx.translate(radius, radius); // 原点を中央に再設定
        }

        /**
         * 初期化処理
         */
        function initializeClock() {
            canvas = document.getElementById("clockCanvas");
            ctx = canvas.getContext("2d");
            
            // 初期リサイズと描画 (原点設定とスケーリングを含む)
            resizeCanvas();
            
            // 初期カラー設定 (CSS変数から取得)
            const initialColor = getNeonColor();
            neonColorState = initialColor;

            // UIの初期値を設定
            document.getElementById('faceImageUrl').value = faceImageUrl; // URLを更新
            document.getElementById('neonColorPicker').value = initialColor;
            document.getElementById('neonColorPreview').style.backgroundColor = initialColor; // プレビューカラー設定
            
            // --- イベントリスナーを設定 ---
            document.getElementById('neonColorPicker').onchange = (e) => changeNeonColor(e.target.value);
            const toggleGridInput = document.getElementById('toggleGrid'); // 新しい変数
            toggleGridInput.onchange = (e) => toggleGridEffect(e.target.checked);
            
            // フルスクリーンボタン
            document.getElementById('fullscreenToggleBtn').onclick = toggleFullscreen;
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            handleFullscreenChange(); // 初期アイコン設定
            
            // モーダルのイベントリスナー
            document.getElementById('openSettingsBtn').onclick = openSettingsModal;
            document.getElementById('closeSettingsBtn').onclick = closeSettingsModal;
            document.getElementById('settingsModal').onclick = (e) => {
                // オーバーレイをクリックした場合も閉じる
                if (e.target.id === 'settingsModal') {
                    closeSettingsModal();
                }
            };
            
            // 初期状態に応じてグリッドエフェクトを適用 (HTMLで'checked'を削除したため、初期値はfalse)
            toggleGridEffect(document.getElementById('toggleGrid').checked); 
            
            // 画像の自動適用
            loadImage(faceImageUrl);

            // 画面サイズ変更時のリサイズ
            window.addEventListener('resize', resizeCanvas);
            
            // アニメーションループ開始
            drawClock(); 
        }

        // ウィンドウの読み込みが完了してから初期化関数を呼び出す
        window.onload = initializeClock;

    </script>
</head>
<body class="font-sans">

    <!-- 時計コンテナ (レスポンシブなサイズ設定) -->
    <div id="clockContainer" class="flex items-center justify-center">
        <canvas id="clockCanvas"></canvas>
        
        <!-- 🖥️ フルスクリーン切り替えボタン (Absolute - 時計コンテナ内、左上隅) -->
        <button id="fullscreenToggleBtn" class="neon-button absolute top-2 left-2 p-2 rounded-full transition duration-300">
            <span id="fullscreenIcon">
                <!-- 初期アイコン: h-5 w-5 -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 8V4h4"/><path d="M20 8V4h-4"/><path d="M4 16v4h4"/><path d="M16 20h4v-4"/>
                </svg>
            </span>
        </button>

        <!-- ⚙️ 設定アイコンボタン (Absolute - 時計コンテナ内、右上隅) -->
        <!-- 変更点: p-3 から p-2 に、h-6 w-6 から h-5 w-5 に変更し、フルスクリーンボタンとサイズを合わせました -->
        <button id="openSettingsBtn" class="neon-button absolute top-2 right-2 p-2 rounded-full transition duration-300">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37h.001z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>
    </div>
    
    <!-- 設定ポップアップ/モーダル (初期状態では非表示) -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-70 z-40 hidden flex items-center justify-center p-4">
        <!-- モーダルコンテンツ -->
        <div id="settingsModalContent" class="bg-gray-800 rounded-xl shadow-2xl w-full max-w-lg space-y-4 relative p-6 modal-enter">
            <!-- 閉じるボタン -->
            <button id="closeSettingsBtn" class="absolute top-3 right-3 text-gray-400 hover:text-[var(--neon-color)] transition duration-150 p-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            
            <h2 class="text-2xl font-extrabold text-white border-b border-gray-600 pb-3">時計設定</h2>

            <!-- ネオンカラー設定 -->
            <div>
                <label for="neonColorPicker" class="block text-sm font-bold text-gray-200 mb-2 flex items-center">
                    ネオンカラーを選択: 
                    <span id="neonColorPreview" class="ml-2 w-5 h-5 rounded-full inline-block border-2 border-white/50"></span>
                </label>
                <input type="color" id="neonColorPicker" class="w-full h-10 p-1 border-gray-500 rounded-md bg-gray-900 cursor-pointer" />
            </div>

            <!-- グリッドエフェクトトグル -->
            <div class="flex items-center justify-between pt-2">
                <label for="toggleGrid" class="text-sm font-bold text-gray-200">背景グリッドエフェクト</label>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggleGrid" class="sr-only peer"> 
                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-[var(--neon-color)]"></div>
                </label>
            </div>

            <!-- カスタム画像設定 -->
            <div class="pt-4 border-t border-gray-600">
                <label for="faceImageUrl" class="block text-sm font-bold text-gray-200 mb-2">カスタム文字盤画像URL</label>
                <input type="url" id="faceImageUrl" placeholder="画像を適用したいURLを入力してください" class="w-full p-2 border border-gray-500 rounded-md bg-gray-900 text-gray-100 placeholder-gray-400 focus:ring-2 focus:ring-[var(--neon-color)] focus:border-[var(--neon-color)]" />
                <button onclick="applyImage(); closeSettingsModal();" class="mt-3 w-full bg-[var(--neon-color)] text-gray-900 py-2 rounded-md font-bold hover:opacity-90 transition duration-150 shadow-md shadow-[var(--neon-color)]/50">
                    画像を適用 / 更新
                </button>
                <p class="text-xs text-gray-400 mt-2">※ 外部URLを使用する場合、CORSポリシーにより表示できないことがあります。</p>
            </div>
        </div>
    </div>
    
    <!-- メッセージボックス -->
    <div id="messageBox" class="fixed bottom-4 right-4 text-white p-3 rounded-lg shadow-xl hidden opacity-0 z-50"></div>
    
</body>
</html>
