<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ネオン風 駅時計</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSSカスタムプロパティを定義 */
        :root {
            --neon-color: #c7ff44; /* ネオンカラーを #c7ff44 に更新 */
            --dark-background: #111111; /* 一番外側の背景色を濃い黒に変更 */
            --safe-size: 96vmin; /* JSがロードされるまでのフォールバックサイズ */
        }
        
        /* 全体レイアウト */
        body { 
            font-family: 'Inter', sans-serif; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 中央寄せ */
            padding: 0; /* パディングを削除して最大化 */
            background-color: var(--dark-background); 
            position: relative; /* グリッドエフェクトの基準点 */
            color: white;
            transition: background-color 0.5s;
            overflow: hidden; /* スクロールを禁止 */
        }

        /* --- iOS擬似フルスクリーン用スタイル (アドレスバー非表示は不可) --- */
        .ios-fullscreen-active {
            margin: 0 !important;
            padding: 0 !important;
            width: 100vw;
            height: 100vh;
        }
        /* iOS擬似フルスクリーン時の時計コンテナのサイズ調整はJSで行うため、CSSはほぼ不要 */
        /* -------------------------------------- */

        /* --- グリッド/スキャンラインエフェクト --- */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* subtle grid pattern */
            background: 
                repeating-linear-gradient(to right, rgba(0,0,0,.15), rgba(0,0,0,.15) 1px, transparent 1px, transparent 40px),
                repeating-linear-gradient(to bottom, rgba(0,0,0,.15), rgba(0,0,0,.15) 1px, transparent 1px, transparent 40px);
            z-index: -1;
            opacity: 0.5;
            transition: opacity 0.5s;
        }
        .no-grid::before {
            opacity: 0;
        }
        /* -------------------------------------- */
        
        /* ボタンのスタイル */
        .neon-button {
            background-color: var(--dark-background); 
            color: white;
            transition: transform 0.3s, background-color 0.3s, box-shadow 0.3s;
            z-index: 30;
        }
        .neon-button:hover {
            transform: scale(1.05);
        }
        .is-fullscreen {
            background-color: #222222; 
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5) inset;
            transform: scale(1.02);
        }
        .is-fullscreen:hover {
            transform: scale(1.08);
        }


        /* 時計コンテナのスタイル - レスポンシブの中核 */
        #clockContainer {
            /* 変更: JSで計算し、短い辺に常に収まる安全なサイズを使用 */
            width: var(--safe-size);      
            height: var(--safe-size); /* 正方形を維持 */
            
            max-width: 100%;    
            max-height: 100%; 
            aspect-ratio: 1 / 1; 
            background-color: transparent; 
            border-radius: 0; 
            box-shadow: none; 
            padding: 0;
            transition: transform 300ms;
            position: relative; 
        }

        /* Canvasのスタイル */
        #clockCanvas {
            border-radius: 0; 
            display: block; 
            width: 100%;
            height: 100%;
        }

        /* モーダル表示のためのユーティリティクラス */
        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }
        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 300ms, transform 300ms;
        }
    </style>
    <script>
        // グローバル変数
        let canvas, ctx, radius;
        let neonColorState; // 現在のネオン色を保持する状態変数
        
        // 設定
        const DIAL_COLOR = '#225822'; // 文字盤の内部背景色

        // 文字盤画像の設定
        let faceImageUrl = 'https://raw.githubusercontent.com/AfterEffects-OK/Ekidokei/main/base.png'; 
        let faceImageObj = null;
        let isImageLoaded = false;

        /**
         * 角度をラジアンに変換するヘルパー関数
         */
        function toRadians(degrees) {
            return (Math.PI / 180) * degrees;
        }
        
        /**
         * CSSカスタムプロパティから現在のネオン色を取得
         */
        function getNeonColor() {
            return getComputedStyle(document.documentElement).getPropertyValue('--neon-color').trim();
        }

        /**
         * ユーザーエージェントからiOSデバイスを判定
         */
        function isIOS() {
            return [
                'iPad Simulator',
                'iPhone Simulator',
                'iPod Simulator',
                'iPad',
                'iPhone',
                'iPod'
            ].includes(navigator.platform)
            // iPadOS 13+ detection
            || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
        }

        /**
         * メッセージボックスを表示する
         */
        function showMessage(message, colorClass = 'bg-blue-500') {
            const box = document.getElementById('messageBox');
            box.className = `fixed bottom-4 right-4 text-white p-3 rounded-lg shadow-xl transition-opacity duration-300 z-50 ${colorClass}`;
            box.textContent = message;
            box.classList.remove('hidden', 'opacity-0');
            box.classList.add('opacity-100');

            setTimeout(() => {
                box.classList.remove('opacity-100');
                box.classList.add('opacity-0');
                setTimeout(() => box.classList.add('hidden'), 300);
            }, 5000); 
        }

        /**
         * 画像を非同期で読み込み、Canvasに適用する
         */
        function loadImage(url) {
            isImageLoaded = false;
            faceImageObj = null;

            if (!url || url.trim() === '') {
                drawClock(); 
                return;
            }

            const img = new Image();
            img.crossOrigin = 'anonymous'; 
            
            const timeout = setTimeout(() => {
                img.onload = null; 
                img.onerror = null; 
                showMessage(`画像ロードがタイムアウトしました。`, 'bg-red-500');
                drawClock();
            }, 5000); 

            img.onload = () => {
                clearTimeout(timeout); 
                faceImageObj = img;
                isImageLoaded = true;
                showMessage('新しい文字盤画像を適用しました。', 'bg-green-500');
            };
            img.onerror = () => {
                clearTimeout(timeout); 
                showMessage(`カスタム画像の読み込みに失敗しました。URLを確認してください。`, 'bg-red-500');
            };
            img.src = url;
        }

        /**
         * UIからURLを取得し、画像ロードをトリガーする
         */
        function applyImage() {
            faceImageUrl = document.getElementById('faceImageUrl').value;
            loadImage(faceImageUrl);
        }
        
        /**
         * ネオンカラーの変更を適用する
         */
        function changeNeonColor(newColor) {
            document.documentElement.style.setProperty('--neon-color', newColor);
            neonColorState = newColor;
            
            document.getElementById('neonColorPreview').style.backgroundColor = newColor;
            
            showMessage(`ネオンカラーを ${newColor} に変更しました。`, 'bg-indigo-500');
        }

        /**
         * グリッドエフェクトの表示/非表示を切り替える
         */
        function toggleGridEffect(isOn) {
            document.body.classList.toggle('no-grid', !isOn);
            showMessage(`背景グリッドエフェクトを${isOn ? '有効' : '無効'}にしました。`, 'bg-indigo-500');
        }

        /**
         * フルスクリーンモードの切り替え
         */
        function toggleFullscreen() {
            if (isIOS()) {
                const isCurrentlyPseudoFullscreen = document.body.classList.contains('ios-fullscreen-active');
                
                document.body.classList.toggle('ios-fullscreen-active', !isCurrentlyPseudoFullscreen);
                handleFullscreenChange(); 
                resizeCanvas(); // フルスクリーン状態が変わったら即座にリサイズを強制実行

                const message = !isCurrentlyPseudoFullscreen 
                    ? '【iOSの制限】完全にフルスクリーンにするには、「ホーム画面に追加」してPWAとして起動してください。擬似フルスクリーンモードを有効にしました。'
                    : '擬似フルスクリーンモードを無効にしました。';
                showMessage(message, !isCurrentlyPseudoFullscreen ? 'bg-yellow-600' : 'bg-indigo-500');
                return;
            }

            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    showMessage(`フルスクリーンモードを開始できませんでした: ${err.message}`, 'bg-red-500');
                });
            } else {
                document.exitFullscreen();
            }
        }

        /**
         * フルスクリーン状態が変更されたときにボタンのアイコンを更新する
         */
        function handleFullscreenChange() {
            const btn = document.getElementById('fullscreenToggleBtn');
            const iconContainer = btn.querySelector('#fullscreenIcon');
            
            const isFullscreen = document.fullscreenElement || document.body.classList.contains('ios-fullscreen-active');

            btn.classList.toggle('is-fullscreen', isFullscreen); 
            
            iconContainer.innerHTML = ''; 

            if (isFullscreen) {
                // フルスクリーン中のアイコン (最小化/終了)
                iconContainer.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
                    </svg>
                `;
            } else {
                // 通常モードのアイコン (最大化/開始)
                iconContainer.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 8V4h4"/><path d="M20 8V4h-4"/><path d="M4 16v4h4"/><path d="M16 20h4v-4"/>
                    </svg>
                `;
            }
        }
        
        /**
         * 設定モーダルを開く
         */
        function openSettingsModal() {
            const modal = document.getElementById('settingsModal');
            const content = document.getElementById('settingsModalContent');
            
            modal.classList.remove('hidden');
            
            content.classList.remove('modal-enter');
            content.classList.add('modal-enter-active');
            
            document.getElementById('faceImageUrl').value = faceImageUrl;
        }

        /**
         * 設定モーダルを閉じる
         */
        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            const content = document.getElementById('settingsModalContent');

            content.classList.remove('modal-enter-active');
            content.classList.add('modal-enter');

            setTimeout(() => {
                 modal.classList.add('hidden');
            }, 300);
        }

        /**
         * 時計の描画処理をフレームレートに合わせて実行
         */
        function drawClock() {
            ctx.clearRect(-radius, -radius, radius * 2, radius * 2); 
            
            drawFace(ctx, radius);
            
            const now = new Date();
            let h = now.getHours();
            const m = now.getMinutes();
            const s = now.getSeconds();
            
            const digitalText = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            
            const color = neonColorState;

            ctx.save();
            
            ctx.font = 'bold ' + radius * 0.12 + "px Inter, sans-serif";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            
            const yPosition = radius * 0.20; 
            const textMetrics = ctx.measureText(digitalText);
            const textWidth = textMetrics.width;
            const textHeight = radius * 0.12 * 1.2;
            
            // 1. 黒い背景を描画
            ctx.fillStyle = '#000000'; 
            ctx.shadowBlur = 0; 
            ctx.fillRect(
                -textWidth / 2 - radius * 0.02, 
                yPosition - textHeight / 2 - radius * 0.02,
                textWidth + radius * 0.04, 
                textHeight + radius * 0.04 
            );


            // 2. テキスト（ネオンカラー）を描画
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = radius * 0.005; 
            
            ctx.fillText(digitalText, 0, yPosition);

            ctx.restore();
            
            drawTime(ctx, radius); 

            window.requestAnimationFrameId = requestAnimationFrame(drawClock);
        }

        /**
         * 文字盤と目盛り、数字を描画します (ネオン効果込み)
         */
        function drawFace(ctx, radius) {
            const color = neonColorState;

            // 1. 背景色の描画（画像がない場合）
            if (!isImageLoaded) {
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.95, 0, 2 * Math.PI);
                ctx.fillStyle = DIAL_COLOR;
                ctx.fill();
            }

            // 1b. カスタム画像の描画 (正方形クリッピング)
            if (faceImageObj && isImageLoaded) {
                const imgSize = radius * 2; 

                ctx.save();
                ctx.beginPath();
                ctx.rect(-radius, -radius, imgSize, imgSize); 
                ctx.clip(); 
                
                ctx.drawImage(faceImageObj, -radius, -radius, imgSize, imgSize);
                
                ctx.restore(); 
            }

            // 3. 目盛りと数字を描画 (画像が適用されていない場合のみ実行)
            if (!isImageLoaded) { 
                ctx.fillStyle = color; 
                ctx.strokeStyle = color; 
                
                ctx.shadowBlur = radius * 0.015;
                ctx.shadowColor = color;

                // 目盛りを描画
                for (let i = 1; i <= 60; i++) {
                    ctx.beginPath();
                    const angle = toRadians(i * 6); 
                    const isHourMark = i % 5 === 0;

                    const markLength = isHourMark ? radius * 0.08 : radius * 0.03; 
                    const markWidth = isHourMark ? radius * 0.02 : radius * 0.008; 

                    const x1 = Math.sin(angle) * radius * 0.90; 
                    const y1 = -Math.cos(angle) * radius * 0.90; 
                    const x2 = Math.sin(angle) * (radius * 0.90 - markLength); 
                    const y2 = -Math.cos(angle) * (radius * 0.90 - markLength); 
                    
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineWidth = markWidth;
                    ctx.lineCap = 'round'; 
                    ctx.stroke();
                }

                // 数字を描画
                ctx.font = 'bold ' + radius * 0.15 + "px Arial, sans-serif";
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";

                for(let num = 1; num <= 12; num++){
                    const angle = num * Math.PI / 6;
                    const x = radius * 0.75 * Math.sin(angle); 
                    const y = radius * 0.75 * -Math.cos(angle);
                    ctx.fillText(num.toString(), x, y);
                }
            }
        }


        /**
         * 時針、分針、秒針を描画します
         */
        function drawTime(ctx, radius) {
            const now = new Date();
            let hour = now.getHours();
            let minute = now.getMinutes();
            let second = now.getSeconds();
            let millisecond = now.getMilliseconds();
            const color = neonColorState;

            hour = hour % 12;
            let hourAngle = (hour * Math.PI / 6) + (minute * Math.PI / (6 * 60)) + (second * Math.PI / (360 * 60));
            let minuteAngle = (minute * Math.PI / 30) + (second * Math.PI / (30 * 60)) + (millisecond * Math.PI / (30 * 60 * 1000));
            let secondAngle = (second * Math.PI / 30); 

            ctx.shadowBlur = radius * 0.01;
            ctx.shadowColor = color;

            // 秒針を描画
            drawHand(ctx, secondAngle, radius * 0.70, radius * 0.015, color, 'second'); 
            // 分針を描画
            drawHand(ctx, minuteAngle, radius * 0.686, radius * 0.04, color, 'minute'); 
            // 時針を描画
            drawHand(ctx, hourAngle, radius * 0.40, radius * 0.08, color, 'hour'); 

            // 中央のピン
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.04, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.shadowBlur = radius * 0.025; 
            ctx.shadowColor = color;
            ctx.fill();

            // 全てのグロー効果をリセット
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        /**
         * 針の描画ヘルパー関数 (太い本体と尖った先端を持つ多角形描画)
         */
        function drawHand(ctx, pos, length, baseWidth, color, type) {
            
            ctx.save();
            ctx.rotate(pos); 
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = radius * 0.005; 

            const tailLength = radius * (type === 'second' ? 0.2 : type === 'minute' ? 0.1 : 0.05);
            
            let tipBaseWidth = 0; 
            const tipLengthRatio = (type === 'minute') ? 0.98 : 0.96; 
            
            if (type === 'minute' || type === 'hour') {
                tipBaseWidth = baseWidth * 0.5; 
            }

            ctx.beginPath();
            
            // 1. 根本の左下 (尾部の端)
            ctx.moveTo(-baseWidth / 2, tailLength); 
            
            // 2. 根本の右下 (尾部の端)
            ctx.lineTo(baseWidth / 2, tailLength); 
            
            // 3. 根元上部（中心）の右側
            ctx.lineTo(baseWidth * 0.4, 0); 
            
            if (tipBaseWidth > 0) {
                const bodyLength = length * tipLengthRatio;
                
                // 4. 太い本体の終わり（右側）
                ctx.lineTo(tipBaseWidth / 2, -bodyLength); 
                
                // 5. 頂点 (鋭利な先端)
                ctx.lineTo(0, -length); 
                
                // 6. 太い本体の終わり（左側）
                ctx.lineTo(-tipBaseWidth / 2, -bodyLength);
                
                // 7. 根元上部（中心）の左側に戻る
                ctx.lineTo(-baseWidth * 0.4, 0); 
            } else {
                // 秒針の場合
                ctx.lineTo(0, -length); 
                ctx.lineTo(-baseWidth * 0.4, 0); 
            }

            ctx.closePath();
            
            ctx.fill(); 
            ctx.stroke(); 

            ctx.restore();
        }


        /**
         * Canvasのサイズを親要素に合わせて設定し、再描画する (レスポンシブ対応)
         * この関数がiOSの縦横切り替えの不安定さ対策の中核です。
         */
        function resizeCanvas() {
            // 1. 画面の幅と高さを取得し、短い方を基準にサイズを計算 (iOS対策)
            // window.innerHeightを使用することで、アドレスバーの有無による表示領域の変化に対応します。
            const minDimension = Math.min(window.innerWidth, window.innerHeight);
            
            // 短い方の98%を安全なサイズとして設定 (2%のマージン)
            const safeSize = minDimension * 0.98; 

            // CSSカスタムプロパティに設定して、#clockContainerのサイズを強制的に制御
            document.documentElement.style.setProperty('--safe-size', `${safeSize}px`);
            
            // 2. Canvas自身の物理的なリサイズ処理
            const container = canvas.parentNode;
            // containerのoffsetWidthは、上記で設定したCSSカスタムプロパティによって定義される
            const size = container.offsetWidth; 
            const scale = window.devicePixelRatio || 1;
            
            // 論理サイズを設定
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            // 物理ピクセルサイズを設定
            canvas.width = size * scale;
            canvas.height = size * scale;

            // 描画コンテキストをスケーリング
            ctx.scale(scale, scale);
            
            // 描画の原点を中心に移動し直す
            radius = size / 2;
            ctx.setTransform(scale, 0, 0, scale, 0, 0); // スケールのみ適用し、トランスフォームをリセット
            ctx.translate(radius, radius); // 原点を中央に再設定
        }

        /**
         * 初期化処理
         */
        function initializeClock() {
            canvas = document.getElementById("clockCanvas");
            ctx = canvas.getContext("2d");
            
            // 初期リサイズと描画 (原点設定とスケーリングを含む)
            resizeCanvas();
            
            // 初期カラー設定 (CSS変数から取得)
            const initialColor = getNeonColor();
            neonColorState = initialColor;

            // UIの初期値を設定
            document.getElementById('faceImageUrl').value = faceImageUrl;
            document.getElementById('neonColorPicker').value = initialColor;
            document.getElementById('neonColorPreview').style.backgroundColor = initialColor;
            
            // --- イベントリスナーを設定 ---
            document.getElementById('neonColorPicker').onchange = (e) => changeNeonColor(e.target.value);
            const toggleGridInput = document.getElementById('toggleGrid');
            toggleGridInput.onchange = (e) => toggleGridEffect(e.target.checked);
            
            // フルスクリーンボタン
            document.getElementById('fullscreenToggleBtn').onclick = toggleFullscreen;
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            handleFullscreenChange(); // 初期アイコン設定
            
            // モーダルのイベントリスナー
            document.getElementById('openSettingsBtn').onclick = openSettingsModal;
            document.getElementById('closeSettingsBtn').onclick = closeSettingsModal;
            document.getElementById('settingsModal').onclick = (e) => {
                if (e.target.id === 'settingsModal') {
                    closeSettingsModal();
                }
            };
            
            toggleGridEffect(document.getElementById('toggleGrid').checked); 
            
            // 画像の自動適用
            loadImage(faceImageUrl);

            // 画面サイズ変更時のリサイズ (iOSの縦横切り替えに対応)
            window.addEventListener('resize', resizeCanvas);
            
            // アニメーションループ開始
            drawClock(); 
        }

        // ウィンドウの読み込みが完了してから初期化関数を呼び出す
        window.onload = initializeClock;

    </script>
</head>
<body class="font-sans">

    <!-- 時計コンテナ (レスポンシブなサイズ設定) -->
    <div id="clockContainer" class="flex items-center justify-center">
        <canvas id="clockCanvas"></canvas>
        
        <!-- 🖥️ フルスクリーン切り替えボタン (Absolute - 時計コンテナ内、左上隅) -->
        <button id="fullscreenToggleBtn" class="neon-button absolute top-2 left-2 p-2 rounded-full transition duration-300">
            <span id="fullscreenIcon">
                <!-- 初期アイコン: h-5 w-5 -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 8V4h4"/><path d="M20 8V4h-4"/><path d="M4 16v4h4"/><path d="M16 20h4v-4"/>
                </svg>
            </span>
        </button>

        <!-- ⚙️ 設定アイコンボタン (Absolute - 時計コンテナ内、右上隅) -->
        <button id="openSettingsBtn" class="neon-button absolute top-2 right-2 p-2 rounded-full transition duration-300">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37h.001z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>
    </div>
    
    <!-- 設定ポップアップ/モーダル (初期状態では非表示) -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-70 z-40 hidden flex items-center justify-center p-4">
        <!-- モーダルコンテンツ -->
        <div id="settingsModalContent" class="bg-gray-800 rounded-xl shadow-2xl w-full max-w-lg space-y-4 relative p-6 modal-enter">
            <!-- 閉じるボタン -->
            <button id="closeSettingsBtn" class="absolute top-3 right-3 text-gray-400 hover:text-[var(--neon-color)] transition duration-150 p-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            
            <h2 class="text-2xl font-extrabold text-white border-b border-gray-600 pb-3">時計設定</h2>

            <!-- ネオンカラー設定 -->
            <div>
                <label for="neonColorPicker" class="block text-sm font-bold text-gray-200 mb-2 flex items-center">
                    ネオンカラーを選択: 
                    <span id="neonColorPreview" class="ml-2 w-5 h-5 rounded-full inline-block border-2 border-white/50"></span>
                </label>
                <input type="color" id="neonColorPicker" class="w-full h-10 p-1 border-gray-500 rounded-md bg-gray-900 cursor-pointer" />
            </div>

            <!-- グリッドエフェクトトグル -->
            <div class="flex items-center justify-between pt-2">
                <label for="toggleGrid" class="text-sm font-bold text-gray-200">背景グリッドエフェクト</label>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggleGrid" class="sr-only peer"> 
                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-[var(--neon-color)]"></div>
                </label>
            </div>

            <!-- カスタム画像設定 -->
            <div class="pt-4 border-t border-gray-600">
                <label for="faceImageUrl" class="block text-sm font-bold text-gray-200 mb-2">カスタム文字盤画像URL</label>
                <input type="url" id="faceImageUrl" placeholder="画像を適用したいURLを入力してください" class="w-full p-2 border border-gray-500 rounded-md bg-gray-900 text-gray-100 placeholder-gray-400 focus:ring-2 focus:ring-[var(--neon-color)] focus:border-[var(--neon-color)]" />
                <button onclick="applyImage(); closeSettingsModal();" class="mt-3 w-full bg-[var(--neon-color)] text-gray-900 py-2 rounded-md font-bold hover:opacity-90 transition duration-150 shadow-md shadow-[var(--neon-color)]/50">
                    画像を適用 / 更新
                </button>
                <p class="text-xs text-gray-400 mt-2">※ 外部URLを使用する場合、CORSポリシーにより表示できないことがあります。</p>
            </div>
        </div>
    </div>
    
    <!-- メッセージボックス -->
    <div id="messageBox" class="fixed bottom-4 right-4 text-white p-3 rounded-lg shadow-xl hidden opacity-0 z-50"></div>
    
</body>
</html>
